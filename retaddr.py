#!/usr/bin/python

import os
from binascii import unhexlify

#function to generate return address of jmp *%esp instruction
def retAddrEsp():
	my_str=""
	for line in open('objdump','r'):
		#print("yes")
		if 'ff e4' in line:
			my_str=line				
	x=my_str.index(':')+2 #Index of First Opcode
	#print('x is'+str(x))
	y=my_str.index('ff e4') #Index of first occurence of 'ff e4'
	#print('y is'+str(y))
	z=int((y-x)/3) #Seperation between both
	#print('z is'+str(z))
	addr = my_str[0:(x-2)] #Address of the First opcode in HEX
	a1=int(hex(int(addr,16)),16)
	#print(hex(a1))
	a2=int(hex(z),16)
	#print(a2)
	addr_esp=hex(a1+a2) #print(addr_esp) #Address of FF E4 is 0x8048442
	#addr = addr_esp[2:]
	#print(addr_esp)
	print(type(addr_esp))
	return addr_esp

#function to generate return address of call *%eax instruction
def retAddrEax():
	my_str=""
	for line in open('objdump','r'):
		#print("yes")
		if '*%eax' in line:
			my_str=line		
		
	addr_eax = my_str.split()[0].strip(':')
	#print(addr_eax)
	x=hex(int(addr_eax,16))	
	#print("address inside retadder"+str(x))	
	return x

	
def retLilEndian(addr):
	#print('received address in lil end conversion:'+addr)
	addr_le=addr[2:]
	if(not len(addr_le)%2==0):
		addr_le='0'+addr_le
	
	RetAddr=""
	for i in range(len(addr_le),0, -2):
		RetAddr=RetAddr + addr_le[i-2:i]
	#print(RetAddr)
	print('The little Endian address of '+addr+ ' in hex format is: ' + RetAddr +'\n')
	RetAddr= unhexlify(RetAddr)    
    	return RetAddr
